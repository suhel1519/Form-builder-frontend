{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js", "../../use-sync-external-store/shim/with-selector.js", "../../@tanstack/store/src/index.ts", "../../@tanstack/form-core/src/utils.ts", "../../@tanstack/form-core/src/FormApi.ts", "../../@tanstack/form-core/src/FieldApi.ts", "../../@tanstack/form-core/src/mergeForm.ts", "../../@tanstack/form-core/src/formOptions.ts", "../../@tanstack/react-store/src/index.ts", "../../@tanstack/react-form/src/useIsomorphicLayoutEffect.ts", "../../@tanstack/react-form/src/useField.tsx", "../../@tanstack/react-form/src/useForm.tsx", "../../@tanstack/react-form/src/useTransform.ts"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      shim = require(\"use-sync-external-store/shim\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n", "export type AnyUpdater = (...args: Array<any>) => any\n\nexport type Listener = () => void\n\nexport interface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  onSubscribe?: (\n    listener: Listener,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  onUpdate?: () => void\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener>()\n  state: TState\n  options?: StoreOptions<TState, TUpdater>\n  _batching = false\n  _flushing = 0\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  setState = (updater: TUpdater) => {\n    const previous = this.state\n    this.state = this.options?.updateFn\n      ? this.options.updateFn(previous)(updater)\n      : (updater as any)(previous)\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.()\n\n    // Attempt to flush\n    this._flush()\n  }\n\n  _flush = () => {\n    if (this._batching) return\n    const flushId = ++this._flushing\n    this.listeners.forEach((listener) => {\n      if (this._flushing !== flushId) return\n      listener()\n    })\n  }\n\n  batch = (cb: () => void) => {\n    if (this._batching) return cb()\n    this._batching = true\n    cb()\n    this._batching = false\n    this._flush()\n  }\n}\n", "import type { ValidationCause } from './types'\nimport type { FormValidators } from './FormApi'\nimport type { FieldValidators } from './FieldApi'\n\nexport type UpdaterFn<TInput, TOutput = TInput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput = TInput> =\n  | TOutput\n  | UpdaterFn<TInput, TOutput>\n\n/**\n * @private\n */\nexport function functionalUpdate<TInput, TOutput = TInput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as UpdaterFn<TInput, TOutput>)(input)\n    : updater\n}\n\n/**\n * Get a value from an object using a path, including dot notation.\n * @private\n */\nexport function getBy(obj: any, path: any) {\n  const pathObj = makePathArray(path)\n  return pathObj.reduce((current: any, pathPart: any) => {\n    if (current === null) return null\n    if (typeof current !== 'undefined') {\n      return current[pathPart]\n    }\n    return undefined\n  }, obj)\n}\n\n/**\n * Set a value on an object using a path, including dot notation.\n * @private\n */\nexport function setBy(obj: any, _path: any, updater: Updater<any>) {\n  const path = makePathArray(_path)\n\n  function doSet(parent?: any): any {\n    if (!path.length) {\n      return functionalUpdate(updater, parent)\n    }\n\n    const key = path.shift()\n\n    if (typeof key === 'string') {\n      if (typeof parent === 'object') {\n        if (parent === null) {\n          parent = {}\n        }\n        return {\n          ...parent,\n          [key]: doSet(parent[key]),\n        }\n      }\n      return {\n        [key]: doSet(),\n      }\n    }\n\n    if (Array.isArray(parent) && key !== undefined) {\n      const prefix = parent.slice(0, key)\n      return [\n        ...(prefix.length ? prefix : new Array(key)),\n        doSet(parent[key]),\n        ...parent.slice(key + 1),\n      ]\n    }\n    return [...new Array(key), doSet()]\n  }\n\n  return doSet(obj)\n}\n\n/**\n * Delete a field on an object using a path, including dot notation.\n * @private\n */\nexport function deleteBy(obj: any, _path: any) {\n  const path = makePathArray(_path)\n\n  function doDelete(parent: any): any {\n    if (!parent) return\n    if (path.length === 1) {\n      const finalPath = path[0]!\n      if (Array.isArray(parent) && typeof finalPath === 'number') {\n        return parent.filter((_, i) => i !== finalPath)\n      }\n      const { [finalPath]: remove, ...rest } = parent\n      return rest\n    }\n\n    const key = path.shift()\n\n    if (typeof key === 'string') {\n      if (typeof parent === 'object') {\n        return {\n          ...parent,\n          [key]: doDelete(parent[key]),\n        }\n      }\n    }\n\n    if (typeof key === 'number') {\n      if (Array.isArray(parent)) {\n        if (key >= parent.length) {\n          return parent\n        }\n        const prefix = parent.slice(0, key)\n        return [\n          ...(prefix.length ? prefix : new Array(key)),\n          doDelete(parent[key]),\n          ...parent.slice(key + 1),\n        ]\n      }\n    }\n\n    throw new Error('It seems we have created an infinite loop in deleteBy. ')\n  }\n\n  return doDelete(obj)\n}\n\nconst reFindNumbers0 = /^(\\d*)$/gm\nconst reFindNumbers1 = /\\.(\\d*)\\./gm\nconst reFindNumbers2 = /^(\\d*)\\./gm\nconst reFindNumbers3 = /\\.(\\d*$)/gm\nconst reFindMultiplePeriods = /\\.{2,}/gm\n\nconst intPrefix = '__int__'\nconst intReplace = `${intPrefix}$1`\n\n/**\n * @private\n */\nexport function makePathArray(str: string) {\n  if (typeof str !== 'string') {\n    throw new Error('Path must be a string.')\n  }\n\n  return str\n    .replaceAll('[', '.')\n    .replaceAll(']', '')\n    .replace(reFindNumbers0, intReplace)\n    .replace(reFindNumbers1, `.${intReplace}.`)\n    .replace(reFindNumbers2, `${intReplace}.`)\n    .replace(reFindNumbers3, `.${intReplace}`)\n    .replace(reFindMultiplePeriods, '.')\n    .split('.')\n    .map((d) => {\n      if (d.indexOf(intPrefix) === 0) {\n        return parseInt(d.substring(intPrefix.length), 10)\n      }\n      return d\n    })\n}\n\n/**\n * @private\n */\nexport function isNonEmptyArray(obj: any) {\n  return !(Array.isArray(obj) && obj.length === 0)\n}\n\ninterface AsyncValidatorArrayPartialOptions<T> {\n  validators?: T\n  asyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface AsyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n  debounceMs: number\n}\n\n/**\n * @private\n */\nexport function getAsyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: AsyncValidatorArrayPartialOptions<T>,\n): T extends FieldValidators<any, any>\n  ? Array<\n      AsyncValidator<T['onChangeAsync'] | T['onBlurAsync'] | T['onSubmitAsync']>\n    >\n  : T extends FormValidators<any, any>\n    ? Array<\n        AsyncValidator<\n          T['onChangeAsync'] | T['onBlurAsync'] | T['onSubmitAsync']\n        >\n      >\n    : never {\n  const { asyncDebounceMs } = options\n  const {\n    onChangeAsync,\n    onBlurAsync,\n    onSubmitAsync,\n    onBlurAsyncDebounceMs,\n    onChangeAsyncDebounceMs,\n  } = (options.validators || {}) as\n    | FieldValidators<any, any>\n    | FormValidators<any, any>\n\n  const defaultDebounceMs = asyncDebounceMs ?? 0\n\n  const changeValidator = {\n    cause: 'change',\n    validate: onChangeAsync,\n    debounceMs: onChangeAsyncDebounceMs ?? defaultDebounceMs,\n  } as const\n\n  const blurValidator = {\n    cause: 'blur',\n    validate: onBlurAsync,\n    debounceMs: onBlurAsyncDebounceMs ?? defaultDebounceMs,\n  } as const\n\n  const submitValidator = {\n    cause: 'submit',\n    validate: onSubmitAsync,\n    debounceMs: 0,\n  } as const\n\n  const noopValidator = (\n    validator:\n      | typeof changeValidator\n      | typeof blurValidator\n      | typeof submitValidator,\n  ) => ({ ...validator, debounceMs: 0 }) as const\n\n  switch (cause) {\n    case 'submit':\n      return [\n        noopValidator(changeValidator),\n        noopValidator(blurValidator),\n        submitValidator,\n      ] as never\n    case 'blur':\n      return [blurValidator] as never\n    case 'change':\n      return [changeValidator] as never\n    case 'server':\n    default:\n      return [] as never\n  }\n}\n\ninterface SyncValidatorArrayPartialOptions<T> {\n  validators?: T\n}\n\n/**\n * @private\n */\nexport interface SyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n}\n\n/**\n * @private\n */\nexport function getSyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: SyncValidatorArrayPartialOptions<T>,\n): T extends FieldValidators<any, any>\n  ? Array<SyncValidator<T['onChange'] | T['onBlur'] | T['onSubmit']>>\n  : T extends FormValidators<any, any>\n    ? Array<SyncValidator<T['onChange'] | T['onBlur'] | T['onSubmit']>>\n    : never {\n  const { onChange, onBlur, onSubmit } = (options.validators || {}) as\n    | FieldValidators<any, any>\n    | FormValidators<any, any>\n\n  const changeValidator = { cause: 'change', validate: onChange } as const\n  const blurValidator = { cause: 'blur', validate: onBlur } as const\n  const submitValidator = { cause: 'submit', validate: onSubmit } as const\n\n  // Allows us to clear onServer errors\n  const serverValidator = {\n    cause: 'server',\n    validate: () => undefined,\n  } as const\n\n  switch (cause) {\n    case 'submit':\n      return [\n        changeValidator,\n        blurValidator,\n        submitValidator,\n        serverValidator,\n      ] as never\n    case 'server':\n      return [serverValidator] as never\n    case 'blur':\n      return [blurValidator, serverValidator] as never\n    case 'change':\n    default:\n      return [changeValidator, serverValidator] as never\n  }\n}\n", "import { Store } from '@tanstack/store'\nimport {\n  deleteBy,\n  functionalUpdate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  isNonEmptyArray,\n  setBy,\n} from './utils'\nimport type { Updater } from './utils'\nimport type { DeepKeys, DeepValue } from './util-types'\nimport type { FieldApi, FieldMeta } from './FieldApi'\nimport type {\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapKeys,\n  Validator,\n} from './types'\n\n/**\n * @private\n */\nexport type FormValidateFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = (props: {\n  value: TFormData\n  formApi: FormApi<TFormData, TFormValidator>\n}) => ValidationError\n\n/**\n * @private\n */\nexport type FormValidateOrFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> =\n  TFormValidator extends Validator<TFormData, infer TFN>\n    ? TFN\n    : FormValidateFn<TFormData, TFormValidator>\n\n/**\n * @private\n */\nexport type FormValidateAsyncFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = (props: {\n  value: TFormData\n  formApi: FormApi<TFormData, TFormValidator>\n  signal: AbortSignal\n}) => ValidationError | Promise<ValidationError>\n\n/**\n * @private\n */\nexport type FormAsyncValidateOrFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> =\n  TFormValidator extends Validator<TFormData, infer FFN>\n    ? FFN | FormValidateAsyncFn<TFormData, TFormValidator>\n    : FormValidateAsyncFn<TFormData, TFormValidator>\n\nexport interface FormValidators<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  /**\n   * Optional function that fires as soon as the component mounts.\n   */\n  onMount?: FormValidateOrFn<TFormData, TFormValidator>\n  /**\n   * Optional function that checks the validity of your data whenever a value changes\n   */\n  onChange?: FormValidateOrFn<TFormData, TFormValidator>\n  /**\n   * Optional onChange asynchronous counterpart to onChange. Useful for more complex validation logic that might involve server requests.\n   */\n  onChangeAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * Optional function that validates the form data when a field loses focus, returns a ValidationError\n   */\n  onBlur?: FormValidateOrFn<TFormData, TFormValidator>\n  /**\n   * Optional onBlur asynchronous validation method for when a field loses focus return a `ValidationError` or a promise of `Promise<ValidationError>`\n   */\n  onBlurAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onBlurAsyncDebounceMs?: number\n  onSubmit?: FormValidateOrFn<TFormData, TFormValidator>\n  onSubmitAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>\n}\n\n/**\n * @private\n */\nexport interface FormTransform<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  fn: (\n    formBase: FormApi<TFormData, TFormValidator>,\n  ) => FormApi<TFormData, TFormValidator>\n  deps: unknown[]\n}\n\n/**\n * An object representing the options for a form.\n */\nexport interface FormOptions<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  /**\n   * Set initial values for your form.\n   */\n  defaultValues?: TFormData\n  /**\n   * The default state for the form.\n   */\n  defaultState?: Partial<FormState<TFormData>>\n  /**\n   * If true, always run async validation, even when sync validation has produced an error. Defaults to undefined.\n   */\n  asyncAlways?: boolean\n  /**\n   * Optional time in milliseconds if you want to introduce a delay before firing off an async action.\n   */\n  asyncDebounceMs?: number\n  /**\n   * A validator adapter to support usage of extra validation types (IE: Zod, Yup, or Valibot usage)\n   */\n  validatorAdapter?: TFormValidator\n  /**\n   * A list of validators to pass to the form\n   */\n  validators?: FormValidators<TFormData, TFormValidator>\n  /**\n   * A function to be called when the form is submitted, what should happen once the user submits a valid form returns `any` or a promise `Promise<any>`\n   */\n  onSubmit?: (props: {\n    value: TFormData\n    formApi: FormApi<TFormData, TFormValidator>\n  }) => any | Promise<any>\n  /**\n   * Specify an action for scenarios where the user tries to submit an invalid form.\n   */\n  onSubmitInvalid?: (props: {\n    value: TFormData\n    formApi: FormApi<TFormData, TFormValidator>\n  }) => void\n  transform?: FormTransform<TFormData, TFormValidator>\n}\n\n/**\n * An object representing the validation metadata for a field. Not intended for public usage.\n */\nexport type ValidationMeta = {\n  /**\n   * An abort controller stored in memory to cancel previous async validation attempts.\n   */\n  lastAbortController: AbortController\n}\n\n/**\n * An object representing the field information for a specific field within the form.\n */\nexport type FieldInfo<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = {\n  /**\n   * An instance of the FieldAPI.\n   */\n  instance: FieldApi<\n    TFormData,\n    any,\n    Validator<unknown, unknown> | undefined,\n    TFormValidator\n  > | null\n  /**\n   * A record of field validation internal handling.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n}\n\n/**\n * An object representing the current state of the form.\n */\nexport type FormState<TFormData> = {\n  /**\n   * The current values of the form fields.\n   */\n  values: TFormData\n  /**\n   * A boolean indicating if the form is currently validating.\n   */\n  isFormValidating: boolean\n  /**\n   * A boolean indicating if the form is valid.\n   */\n  isFormValid: boolean\n  /**\n   * The error array for the form itself.\n   */\n  errors: ValidationError[]\n  /**\n   * The error map for the form itself.\n   */\n  errorMap: ValidationErrorMap\n  /**\n   * An internal mechanism used for keeping track of validation logic in a form.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n  /**\n   * A record of field metadata for each field in the form.\n   */\n  fieldMeta: Record<DeepKeys<TFormData>, FieldMeta>\n  /**\n   * A boolean indicating if any of the form fields are currently validating.\n   */\n  isFieldsValidating: boolean\n  /**\n   * A boolean indicating if all the form fields are valid.\n   */\n  isFieldsValid: boolean\n  /**\n   * A boolean indicating if the form is currently submitting.\n   */\n  isSubmitting: boolean\n  /**\n   * A boolean indicating if any of the form fields have been touched.\n   */\n  isTouched: boolean\n  /**\n   * A boolean indicating if any of the form's fields' values have been modified by the user. `True` if the user have modified at least one of the fields. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A boolean indicating if none of the form's fields' values have been modified by the user. `True` if the user have not modified any of the fields. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if the form has been submitted.\n   */\n  isSubmitted: boolean\n  /**\n   * A boolean indicating if the form or any of its fields are currently validating.\n   */\n  isValidating: boolean\n  /**\n   * A boolean indicating if the form and all its fields are valid.\n   */\n  isValid: boolean\n  /**\n   * A boolean indicating if the form can be submitted based on its current state.\n   */\n  canSubmit: boolean\n  /**\n   * A counter for tracking the number of submission attempts.\n   */\n  submissionAttempts: number\n}\n\nfunction getDefaultFormState<TFormData>(\n  defaultState: Partial<FormState<TFormData>>,\n): FormState<TFormData> {\n  return {\n    values: defaultState.values ?? ({} as never),\n    errors: defaultState.errors ?? [],\n    errorMap: defaultState.errorMap ?? {},\n    fieldMeta: defaultState.fieldMeta ?? ({} as never),\n    canSubmit: defaultState.canSubmit ?? true,\n    isFieldsValid: defaultState.isFieldsValid ?? false,\n    isFieldsValidating: defaultState.isFieldsValidating ?? false,\n    isFormValid: defaultState.isFormValid ?? false,\n    isFormValidating: defaultState.isFormValidating ?? false,\n    isSubmitted: defaultState.isSubmitted ?? false,\n    isSubmitting: defaultState.isSubmitting ?? false,\n    isTouched: defaultState.isTouched ?? false,\n    isPristine: defaultState.isPristine ?? true,\n    isDirty: defaultState.isDirty ?? false,\n    isValid: defaultState.isValid ?? false,\n    isValidating: defaultState.isValidating ?? false,\n    submissionAttempts: defaultState.submissionAttempts ?? 0,\n    validationMetaMap: defaultState.validationMetaMap ?? {\n      onChange: undefined,\n      onBlur: undefined,\n      onSubmit: undefined,\n      onMount: undefined,\n      onServer: undefined,\n    },\n  }\n}\n\n/**\n * A class representing the Form API. It handles the logic and interactions with the form state.\n *\n * Normally, you will not need to create a new `FormApi` instance directly. Instead, you will use a framework\n * hook/function like `useForm` or `createForm` to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling the `new FormApi` constructor.\n */\nexport class FormApi<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  /**\n   * The options for the form.\n   */\n  options: FormOptions<TFormData, TFormValidator> = {}\n  /**\n   * A [TanStack Store instance](https://tanstack.com/store/latest/docs/reference/Store) that keeps track of the form's state.\n   */\n  store!: Store<FormState<TFormData>>\n  /**\n   * The current state of the form.\n   *\n   * **Note:**\n   * Do not use `state` directly, as it is not reactive.\n   * Please use form.useStore() utility to subscribe to state\n   */\n  state!: FormState<TFormData>\n  /**\n   * A record of field information for each field in the form.\n   */\n  fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData, TFormValidator>> =\n    {} as any\n\n  /**\n   * @private\n   */\n  prevTransformArray: unknown[] = []\n\n  /**\n   * Constructs a new `FormApi` instance with the given form options.\n   */\n  constructor(opts?: FormOptions<TFormData, TFormValidator>) {\n    this.store = new Store<FormState<TFormData>>(\n      getDefaultFormState({\n        ...(opts?.defaultState as any),\n        values: opts?.defaultValues ?? opts?.defaultState?.values,\n        isFormValid: true,\n      }),\n      {\n        onUpdate: () => {\n          let { state } = this.store\n          // Computed state\n          const fieldMetaValues = Object.values(state.fieldMeta) as (\n            | FieldMeta\n            | undefined\n          )[]\n\n          const isFieldsValidating = fieldMetaValues.some(\n            (field) => field?.isValidating,\n          )\n\n          const isFieldsValid = !fieldMetaValues.some(\n            (field) =>\n              field?.errorMap &&\n              isNonEmptyArray(Object.values(field.errorMap).filter(Boolean)),\n          )\n\n          const isTouched = fieldMetaValues.some((field) => field?.isTouched)\n\n          const isDirty = fieldMetaValues.some((field) => field?.isDirty)\n          const isPristine = !isDirty\n\n          const isValidating = isFieldsValidating || state.isFormValidating\n          state.errors = Object.values(state.errorMap).filter(\n            (val: unknown) => val !== undefined,\n          )\n          const isFormValid = state.errors.length === 0\n          const isValid = isFieldsValid && isFormValid\n          const canSubmit =\n            (state.submissionAttempts === 0 && !isTouched) ||\n            (!isValidating && !state.isSubmitting && isValid)\n\n          state = {\n            ...state,\n            isFieldsValidating,\n            isFieldsValid,\n            isFormValid,\n            isValid,\n            canSubmit,\n            isTouched,\n            isPristine,\n            isDirty,\n          }\n\n          this.state = state\n          this.store.state = this.state\n\n          // Only run transform if state has shallowly changed - IE how React.useEffect works\n          const transformArray = this.options.transform?.deps ?? []\n          const shouldTransform =\n            transformArray.length !== this.prevTransformArray.length ||\n            transformArray.some((val, i) => val !== this.prevTransformArray[i])\n\n          if (shouldTransform) {\n            // This mutates the state\n            this.options.transform?.fn(this)\n            this.store.state = this.state\n            this.prevTransformArray = transformArray\n          }\n        },\n      },\n    )\n\n    this.state = this.store.state\n\n    this.update(opts || {})\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends { value: TFormData; formApi: FormApi<any, any> },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FormValidateOrFn<TFormData, TFormValidator>\n      : FormAsyncValidateOrFn<TFormData, TFormValidator>\n    value: TValue\n    type: TType\n  }): ReturnType<ReturnType<Validator<any>>[TType]> {\n    const adapter = this.options.validatorAdapter\n    if (adapter && typeof props.validate !== 'function') {\n      return adapter()[props.type](props.value, props.validate) as never\n    }\n\n    return (props.validate as FormValidateFn<any, any>)(props.value) as never\n  }\n\n  mount = () => {\n    const { onMount } = this.options.validators || {}\n    if (!onMount) return\n    const error = this.runValidator({\n      validate: onMount,\n      value: {\n        value: this.state.values,\n        formApi: this,\n      },\n      type: 'validate',\n    })\n    if (error) {\n      this.store.setState((prev) => ({\n        ...prev,\n        errorMap: { ...prev.errorMap, onMount: error },\n      }))\n    }\n  }\n\n  /**\n   * Updates the form options and form state.\n   */\n  update = (options?: FormOptions<TFormData, TFormValidator>) => {\n    if (!options) return\n\n    const oldOptions = this.options\n\n    // Options need to be updated first so that when the store is updated, the state is correct for the derived state\n    this.options = options\n\n    this.store.batch(() => {\n      const shouldUpdateValues =\n        options.defaultValues &&\n        options.defaultValues !== oldOptions.defaultValues &&\n        !this.state.isTouched\n\n      const shouldUpdateState =\n        options.defaultState !== oldOptions.defaultState &&\n        !this.state.isTouched\n\n      this.store.setState(() =>\n        getDefaultFormState(\n          Object.assign(\n            {},\n            this.state as any,\n\n            shouldUpdateState ? options.defaultState : {},\n\n            shouldUpdateValues\n              ? {\n                  values: options.defaultValues,\n                }\n              : {},\n          ),\n        ),\n      )\n    })\n  }\n\n  /**\n   * Resets the form state to the default values.\n   */\n  reset = () => {\n    const { fieldMeta: currentFieldMeta } = this.state\n    const fieldMeta = this.resetFieldMeta(currentFieldMeta)\n    this.store.setState(() =>\n      getDefaultFormState({\n        ...(this.options.defaultState as any),\n        values: this.options.defaultValues ?? this.options.defaultState?.values,\n        fieldMeta,\n      }),\n    )\n  }\n\n  /**\n   * Validates all fields in the form using the correct handlers for a given validation type.\n   */\n  validateAllFields = async (cause: ValidationCause) => {\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    this.store.batch(() => {\n      void (\n        Object.values(this.fieldInfo) as FieldInfo<any, TFormValidator>[]\n      ).forEach((field) => {\n        if (!field.instance) return\n        const fieldInstance = field.instance\n        // Validate the field\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => fieldInstance.validate(cause)),\n        )\n        // If any fields are not touched\n        if (!field.instance.state.meta.isTouched) {\n          // Mark them as touched\n          field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n        }\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates the children of a specified array in the form starting from a given index until the end using the correct handlers for a given validation type.\n   */\n  validateArrayFieldsStartingFrom = async <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    cause: ValidationCause,\n  ) => {\n    const currentValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(currentValue)\n      ? Math.max(currentValue.length - 1, 0)\n      : null\n\n    // We have to validate all fields that have shifted (at least the current field)\n    const fieldKeysToValidate = [`${field}[${index}]`]\n    for (let i = index + 1; i <= (lastIndex ?? 0); i++) {\n      fieldKeysToValidate.push(`${field}[${i}]`)\n    }\n\n    // We also have to include all fields that are nested in the shifted fields\n    const fieldsToValidate = Object.keys(this.fieldInfo).filter((fieldKey) =>\n      fieldKeysToValidate.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n\n    // Validate the fields\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    this.store.batch(() => {\n      fieldsToValidate.forEach((nestedField) => {\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => this.validateField(nestedField, cause)),\n        )\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates a specified field in the form using the correct handlers for a given validation type.\n   */\n  validateField = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    cause: ValidationCause,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const fieldInstance = this.fieldInfo[field]?.instance\n    if (!fieldInstance) return []\n\n    // If the field is not touched (same logic as in validateAllFields)\n    if (!fieldInstance.state.meta.isTouched) {\n      // Mark it as touched\n      fieldInstance.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n\n    return fieldInstance.validate(cause)\n  }\n\n  /**\n   * TODO: This code is copied from FieldApi, we should refactor to share\n   * @private\n   */\n  validateSync = (cause: ValidationCause) => {\n    const validates = getSyncValidatorArray(cause, this.options)\n    let hasErrored = false as boolean\n\n    this.store.batch(() => {\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n\n        const error = normalizeError(\n          this.runValidator({\n            validate: validateObj.validate,\n            value: {\n              value: this.state.values,\n              formApi: this,\n            },\n            type: 'validate',\n          }),\n        )\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n        if (this.state.errorMap[errorMapKey] !== error) {\n          this.store.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: error,\n            },\n          }))\n        }\n        if (error) {\n          hasErrored = true\n        }\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n    if (\n      this.state.errorMap[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.store.setState((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n  ): Promise<ValidationError[]> => {\n    const validates = getAsyncValidatorArray(cause, this.options)\n\n    if (!this.state.isFormValidating) {\n      this.store.setState((prev) => ({ ...prev, isFormValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const promises: Promise<ValidationError | undefined>[] = []\n\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = this.state.validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.state.validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate!,\n                      value: {\n                        value: this.state.values,\n                        formApi: this,\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          const error = normalizeError(rawError)\n          this.store.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [getErrorMapKey(cause)]: error,\n            },\n          }))\n\n          resolve(error)\n        }),\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (promises.length) {\n      results = await Promise.all(promises)\n    }\n\n    this.store.setState((prev) => ({\n      ...prev,\n      isFormValidating: false,\n    }))\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * @private\n   */\n  validate = (\n    cause: ValidationCause,\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // Attempt to sync validate first\n    const { hasErrored } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      return this.state.errors\n    }\n\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  /**\n   * Handles the form submission, performs validation, and calls the appropriate onSubmit or onInvalidSubmit callbacks.\n   */\n  handleSubmit = async () => {\n    this.store.setState((old) => ({\n      ...old,\n      // Submission attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n    }))\n\n    // Don't let invalid forms submit\n    if (!this.state.canSubmit) return\n\n    this.store.setState((d) => ({ ...d, isSubmitting: true }))\n\n    const done = () => {\n      this.store.setState((prev) => ({ ...prev, isSubmitting: false }))\n    }\n\n    // Validate all fields\n    await this.validateAllFields('submit')\n\n    // Fields are invalid, do not submit\n    if (!this.state.isFieldsValid) {\n      done()\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n      })\n      return\n    }\n\n    // Run validation for the form\n    await this.validate('submit')\n\n    if (!this.state.isValid) {\n      done()\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n      })\n      return\n    }\n\n    try {\n      // Run the submit code\n      await this.options.onSubmit?.({ value: this.state.values, formApi: this })\n\n      this.store.batch(() => {\n        this.store.setState((prev) => ({ ...prev, isSubmitted: true }))\n        done()\n      })\n    } catch (err) {\n      done()\n      throw err\n    }\n  }\n\n  /**\n   * Gets the value of the specified field.\n   */\n  getFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): DeepValue<TFormData, TField> => getBy(this.state.values, field)\n\n  /**\n   * Gets the metadata of the specified field.\n   */\n  getFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldMeta | undefined => {\n    return this.state.fieldMeta[field]\n  }\n\n  /**\n   * Gets the field info of the specified field.\n   */\n  getFieldInfo = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldInfo<TFormData, TFormValidator> => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return (this.fieldInfo[field] ||= {\n      instance: null,\n      validationMetaMap: {\n        onChange: undefined,\n        onBlur: undefined,\n        onSubmit: undefined,\n        onMount: undefined,\n        onServer: undefined,\n      },\n    })\n  }\n\n  /**\n   * Updates the metadata of the specified field.\n   */\n  setFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<FieldMeta>,\n  ) => {\n    this.store.setState((prev) => {\n      return {\n        ...prev,\n        fieldMeta: {\n          ...prev.fieldMeta,\n          [field]: functionalUpdate(updater, prev.fieldMeta[field]),\n        },\n      }\n    })\n  }\n\n  resetFieldMeta = <TField extends DeepKeys<TFormData>>(\n    fieldMeta: Record<TField, FieldMeta>,\n  ): Record<TField, FieldMeta> => {\n    return Object.keys(fieldMeta).reduce(\n      (acc: Record<TField, FieldMeta>, key) => {\n        const fieldKey = key as TField\n        acc[fieldKey] = {\n          isValidating: false,\n          isTouched: false,\n          isDirty: false,\n          isPristine: true,\n          errors: [],\n          errorMap: {},\n        }\n        return acc\n      },\n      {} as Record<TField, FieldMeta>,\n    )\n  }\n\n  /**\n   * Sets the value of the specified field and optionally updates the touched state.\n   */\n  setFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<DeepValue<TFormData, TField>>,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const dontUpdateMeta = opts?.dontUpdateMeta ?? false\n\n    this.store.batch(() => {\n      if (!dontUpdateMeta) {\n        this.setFieldMeta(field, (prev) => ({\n          ...prev,\n          isTouched: true,\n          isDirty: true,\n        }))\n      }\n\n      this.store.setState((prev) => {\n        return {\n          ...prev,\n          values: setBy(prev.values, field, updater),\n        }\n      })\n    })\n  }\n\n  deleteField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    this.store.setState((prev) => {\n      const newState = { ...prev }\n      newState.values = deleteBy(newState.values, field)\n      delete newState.fieldMeta[field]\n\n      return newState\n    })\n    delete this.fieldInfo[field]\n  }\n\n  /**\n   * Pushes a value into an array field.\n   */\n  pushFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => [...(Array.isArray(prev) ? prev : []), value] as any,\n      opts,\n    )\n    this.validateField(field, 'change')\n  }\n\n  /**\n   * Inserts a value into an array field at the specified index, shifting the subsequent values to the right.\n   */\n  insertFieldValue = async <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return [\n          ...(prev as DeepValue<TFormData, TField>[]).slice(0, index),\n          value,\n          ...(prev as DeepValue<TFormData, TField>[]).slice(index),\n        ] as any\n      },\n      opts,\n    )\n\n    // Validate the whole array + all fields that have shifted\n    await this.validateField(field, 'change')\n  }\n\n  /**\n   * Replaces a value into an array field at the specified index.\n   */\n  replaceFieldValue = async <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).map((d, i) =>\n          i === index ? value : d,\n        ) as any\n      },\n      opts,\n    )\n\n    // Validate the whole array + all fields that have shifted\n    await this.validateField(field, 'change')\n    await this.validateArrayFieldsStartingFrom(field, index, 'change')\n  }\n\n  /**\n   * Removes a value from an array field at the specified index.\n   */\n  removeFieldValue = async <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max(fieldValue.length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).filter(\n          (_d, i) => i !== index,\n        ) as any\n      },\n      opts,\n    )\n\n    if (lastIndex !== null) {\n      const start = `${field}[${lastIndex}]`\n      const fieldsToDelete = Object.keys(this.fieldInfo).filter((f) =>\n        f.startsWith(start),\n      )\n\n      // Cleanup the last fields\n      fieldsToDelete.forEach((f) => this.deleteField(f as TField))\n    }\n\n    // Validate the whole array + all fields that have shifted\n    await this.validateField(field, 'change')\n    await this.validateArrayFieldsStartingFrom(field, index, 'change')\n  }\n\n  /**\n   * Swaps the values at the specified indices within an array field.\n   */\n  swapFieldValues = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const prev1 = prev[index1]!\n        const prev2 = prev[index2]!\n        return setBy(setBy(prev, `${index1}`, prev2), `${index2}`, prev1)\n      },\n      opts,\n    )\n\n    // Validate the whole array\n    this.validateField(field, 'change')\n    // Validate the swapped fields\n    this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n    this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index within an array field.\n   */\n  moveFieldValues = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        prev.splice(index2, 0, prev.splice(index1, 1)[0])\n        return prev\n      },\n      opts,\n    )\n\n    // Validate the whole array\n    this.validateField(field, 'change')\n    // Validate the moved fields\n    this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n    this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n  }\n  /**\n   * Updates the form's errorMap\n   */\n  setErrorMap(errorMap: ValidationErrorMap) {\n    this.store.setState((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    if (typeof rawError !== 'string') {\n      return 'Invalid Form Values'\n    }\n\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n", "import { Store } from '@tanstack/store'\nimport { getAsyncValidatorArray, getBy, getSyncValidatorArray } from './utils'\nimport type {\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  Validator,\n} from './types'\nimport type { FieldInfo, FormApi } from './FormApi'\nimport type { AsyncValidator, SyncValidator, Updater } from './utils'\nimport type { DeepKeys, DeepValue, NoInfer } from './util-types'\n\n/**\n * @private\n */\nexport type FieldValidateFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<TParentData, TName, TFieldValidator, TFormValidator, TData>\n}) => ValidationError\n\n/**\n * @private\n */\nexport type FieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  TFieldValidator extends Validator<TData, infer TFN>\n    ?\n        | TFN\n        | FieldValidateFn<\n            TParentData,\n            TName,\n            TFieldValidator,\n            TFormValidator,\n            TData\n          >\n    : TFormValidator extends Validator<TParentData, infer FFN>\n      ?\n          | FFN\n          | FieldValidateFn<\n              TParentData,\n              TName,\n              TFieldValidator,\n              TFormValidator,\n              TData\n            >\n      : FieldValidateFn<\n          TParentData,\n          TName,\n          TFieldValidator,\n          TFormValidator,\n          TData\n        >\n\n/**\n * @private\n */\nexport type FieldValidateAsyncFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (options: {\n  value: TData\n  fieldApi: FieldApi<TParentData, TName, TFieldValidator, TFormValidator, TData>\n  signal: AbortSignal\n}) => ValidationError | Promise<ValidationError>\n\n/**\n * @private\n */\nexport type FieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  TFieldValidator extends Validator<TData, infer TFN>\n    ?\n        | TFN\n        | FieldValidateAsyncFn<\n            TParentData,\n            TName,\n            TFieldValidator,\n            TFormValidator,\n            TData\n          >\n    : TFormValidator extends Validator<TParentData, infer FFN>\n      ?\n          | FFN\n          | FieldValidateAsyncFn<\n              TParentData,\n              TName,\n              TFieldValidator,\n              TFormValidator,\n              TData\n            >\n      : FieldValidateAsyncFn<\n          TParentData,\n          TName,\n          TFieldValidator,\n          TFormValidator,\n          TData\n        >\n\nexport interface FieldValidators<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  /**\n   * An optional function that takes a param of `formApi` which is a generic type of `TData` and `TParentData`\n   */\n  onMount?: FieldValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional property that takes a `ValidateFn` which is a generic of `TData` and `TParentData`.\n   * If `validatorAdapter` is passed, this may also accept a property from the respective adapter\n   *\n   * @example `z.string().min(1)` if `zodAdapter` is passed\n   */\n  onChange?: FieldValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional property similar to `onChange` but async validation. If `validatorAdapter`\n   * is passed, this may also accept a property from the respective adapter\n   *\n   * @example `z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })` if `zodAdapter` is passed\n   */\n  onChangeAsync?: FieldAsyncValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional number to represent how long the `onChangeAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onChange` and `onChangeAsync` events when its value changes\n   */\n  onChangeListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that when run when subscribing to blur event of input.\n   * If `validatorAdapter` is passed, this may also accept a property from the respective adapter\n   *\n   * @example `z.string().min(1)` if `zodAdapter` is passed\n   */\n  onBlur?: FieldValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional property similar to `onBlur` but async validation. If `validatorAdapter`\n   * is passed, this may also accept a property from the respective adapter\n   *\n   * @example `z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })` if `zodAdapter` is passed\n   */\n  onBlurAsync?: FieldAsyncValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n\n  /**\n   * An optional number to represent how long the `onBlurAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onBlurAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onBlur` and `onBlurAsync` events when its value changes\n   */\n  onBlurListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that when run when subscribing to submit event of input.\n   * If `validatorAdapter` is passed, this may also accept a property from the respective adapter\n   *\n   * @example `z.string().min(1)` if `zodAdapter` is passed\n   */\n  onSubmit?: FieldValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional property similar to `onSubmit` but async validation. If `validatorAdapter`\n   * is passed, this may also accept a property from the respective adapter\n   *\n   * @example `z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })` if `zodAdapter` is passed\n   */\n  onSubmitAsync?: FieldAsyncValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n}\n\n/**\n * An object type representing the options for a field in a form.\n */\nexport interface FieldOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  /**\n   * The field name. The type will be `DeepKeys<TParentData>` to ensure your name is a deep key of the parent dataset.\n   */\n  name: TName\n  /**\n   * An optional default value for the field.\n   */\n  defaultValue?: NoInfer<TData>\n  /**\n   * The default time to debounce async validation if there is not a more specific debounce time passed.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If `true`, always run async validation, even if there are errors emitted during synchronous validation.\n   */\n  asyncAlways?: boolean\n  /**\n   * A validator provided by an extension, like `yupValidator` from `@tanstack/yup-form-adapter`\n   */\n  validatorAdapter?: TFieldValidator\n  /**\n   * A list of validators to pass to the field\n   */\n  validators?: FieldValidators<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional object with default metadata for the field.\n   */\n  defaultMeta?: Partial<FieldMeta>\n}\n\n/**\n * An object type representing the required options for the FieldApi class.\n */\nexport interface FieldApiOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> extends FieldOptions<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  > {\n  form: FormApi<TParentData, TFormValidator>\n}\n\n/**\n * An object type representing the metadata of a field in a form.\n */\nexport type FieldMeta = {\n  /**\n   * A flag indicating whether the field has been touched.\n   */\n  isTouched: boolean\n  /**\n   * A flag that is `true` if the field's value has not been modified by the user. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A flag that is `true` if the field's value has been modified by the user. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * An array of errors related to the field value.\n   */\n  errors: ValidationError[]\n  /**\n   * A map of errors related to the field value.\n   */\n  errorMap: ValidationErrorMap\n  /**\n   * A flag indicating whether the field is currently being validated.\n   */\n  isValidating: boolean\n}\n\n/**\n * An object type representing the state of a field.\n */\nexport type FieldState<TData> = {\n  /**\n   * The current value of the field.\n   */\n  value: TData\n  /**\n   * The current metadata of the field.\n   */\n  meta: FieldMeta\n}\n\n/**\n * A class representing the API for managing a form field.\n *\n * Normally, you will not need to create a new `FieldApi` instance directly.\n * Instead, you will use a framework hook/function like `useField` or `createField`\n * to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling\n * the `new FieldApi` constructor.\n */\nexport class FieldApi<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  /**\n   * A reference to the form API instance.\n   */\n  form: FieldApiOptions<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >['form']\n  /**\n   * The field name.\n   */\n  name!: DeepKeys<TParentData>\n  /**\n   * The field options.\n   */\n  options: FieldApiOptions<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  > = {} as any\n  /**\n   * The field state store.\n   */\n  store!: Store<FieldState<TData>>\n  /**\n   * The current field state.\n   */\n  state!: FieldState<TData>\n  /**\n   * @private\n   */\n  prevState!: FieldState<TData>\n\n  /**\n   * Initializes a new `FieldApi` instance.\n   */\n  constructor(\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TFieldValidator,\n      TFormValidator,\n      TData\n    >,\n  ) {\n    this.form = opts.form as never\n    this.name = opts.name as never\n\n    if (opts.defaultValue !== undefined) {\n      this.form.setFieldValue(this.name, opts.defaultValue as never, {\n        dontUpdateMeta: true,\n      })\n    }\n\n    this.store = new Store<FieldState<TData>>(\n      {\n        value: this.getValue(),\n\n        meta: this._getMeta() ?? {\n          isValidating: false,\n          isTouched: false,\n          isDirty: false,\n          isPristine: true,\n          errors: [],\n          errorMap: {},\n          ...opts.defaultMeta,\n        },\n      },\n      {\n        onUpdate: () => {\n          const state = this.store.state\n\n          state.meta.errors = Object.values(state.meta.errorMap).filter(\n            (val: unknown) => val !== undefined,\n          )\n\n          state.meta.isPristine = !state.meta.isDirty\n\n          this.prevState = state\n          this.state = state\n        },\n      },\n    )\n\n    this.state = this.store.state\n    this.prevState = this.state\n    this.options = opts as never\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends { value: TData; fieldApi: FieldApi<any, any, any, any> },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FieldValidateOrFn<any, any, any, any>\n      : FieldAsyncValidateOrFn<any, any, any, any>\n    value: TValue\n    type: TType\n  }): ReturnType<ReturnType<Validator<any>>[TType]> {\n    const adapters = [\n      this.form.options.validatorAdapter,\n      this.options.validatorAdapter,\n    ] as const\n    for (const adapter of adapters) {\n      if (adapter && typeof props.validate !== 'function') {\n        return adapter()[props.type](\n          props.value as never,\n          props.validate,\n        ) as never\n      }\n    }\n\n    return (props.validate as FieldValidateFn<any, any>)(props.value) as never\n  }\n\n  /**\n   * Mounts the field instance to the form.\n   */\n  mount = () => {\n    const info = this.getInfo()\n    info.instance = this as never\n    const unsubscribe = this.form.store.subscribe(() => {\n      this.store.batch(() => {\n        const nextValue = this.getValue()\n        const nextMeta = this.getMeta()\n\n        if (nextValue !== this.state.value) {\n          this.store.setState((prev) => ({ ...prev, value: nextValue }))\n        }\n\n        if (nextMeta !== this.state.meta) {\n          this.store.setState((prev) => ({ ...prev, meta: nextMeta }))\n        }\n      })\n    })\n\n    this.update(this.options as never)\n    const { onMount } = this.options.validators || {}\n\n    if (onMount) {\n      const error = this.runValidator({\n        validate: onMount,\n        value: {\n          value: this.state.value,\n          fieldApi: this,\n        },\n        type: 'validate',\n      })\n      if (error) {\n        this.setMeta((prev) => ({\n          ...prev,\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          errorMap: { ...prev?.errorMap, onMount: error },\n        }))\n      }\n    }\n\n    return () => {\n      unsubscribe()\n    }\n  }\n\n  /**\n   * Updates the field instance with new options.\n   */\n  update = (\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TFieldValidator,\n      TFormValidator,\n      TData\n    >,\n  ) => {\n    // Default Value\n\n    if (this.state.value === undefined) {\n      const formDefault = getBy(opts.form.options.defaultValues, opts.name)\n\n      if (opts.defaultValue !== undefined) {\n        this.setValue(opts.defaultValue as never, {\n          dontUpdateMeta: true,\n        })\n      } else if (formDefault !== undefined) {\n        this.setValue(formDefault as never, {\n          dontUpdateMeta: true,\n        })\n      }\n    }\n\n    // Default Meta\n    if (this._getMeta() === undefined) {\n      this.setMeta(this.state.meta)\n    }\n\n    this.options = opts as never\n  }\n\n  /**\n   * Gets the current field value.\n   * @deprecated Use `field.state.value` instead.\n   */\n  getValue = (): TData => {\n    return this.form.getFieldValue(this.name) as TData\n  }\n\n  /**\n   * Sets the field value and run the `change` validator.\n   */\n  setValue = (updater: Updater<TData>, options?: UpdateMetaOptions) => {\n    this.form.setFieldValue(this.name, updater as never, options)\n    this.validate('change')\n  }\n\n  /**\n   * @private\n   */\n  _getMeta = () => this.form.getFieldMeta(this.name)\n\n  /**\n   * Gets the current field metadata.\n   */\n  getMeta = () =>\n    this._getMeta() ??\n    ({\n      isValidating: false,\n      isTouched: false,\n      isDirty: false,\n      isPristine: true,\n      errors: [],\n      errorMap: {},\n      ...this.options.defaultMeta,\n    } as FieldMeta)\n\n  /**\n   * Sets the field metadata.\n   */\n  setMeta = (updater: Updater<FieldMeta>) =>\n    this.form.setFieldMeta(this.name, updater)\n\n  /**\n   * Gets the field information object.\n   */\n  getInfo = () => this.form.getFieldInfo(this.name)\n\n  /**\n   * Pushes a new value to the field.\n   */\n  pushValue = (\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => this.form.pushFieldValue(this.name, value as any, opts)\n\n  /**\n   * Inserts a value at the specified index, shifting the subsequent values to the right.\n   */\n  insertValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => this.form.insertFieldValue(this.name, index, value as any, opts)\n\n  /**\n   * Replaces a value at the specified index.\n   */\n  replaceValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => this.form.replaceFieldValue(this.name, index, value as any, opts)\n\n  /**\n   * Removes a value at the specified index.\n   */\n  removeValue = (index: number, opts?: UpdateMetaOptions) =>\n    this.form.removeFieldValue(this.name, index, opts)\n\n  /**\n   * Swaps the values at the specified indices.\n   */\n  swapValues = (aIndex: number, bIndex: number, opts?: UpdateMetaOptions) =>\n    this.form.swapFieldValues(this.name, aIndex, bIndex, opts)\n\n  /**\n   * Moves the value at the first specified index to the second specified index.\n   */\n  moveValue = (aIndex: number, bIndex: number, opts?: UpdateMetaOptions) =>\n    this.form.moveFieldValues(this.name, aIndex, bIndex, opts)\n\n  /**\n   * @private\n   */\n  getLinkedFields = (cause: ValidationCause) => {\n    const fields = Object.values(this.form.fieldInfo) as FieldInfo<\n      any,\n      TFormValidator\n    >[]\n\n    const linkedFields: FieldApi<any, any, any, any>[] = []\n    for (const field of fields) {\n      if (!field.instance) continue\n      const { onChangeListenTo, onBlurListenTo } =\n        field.instance.options.validators || {}\n      if (\n        cause === 'change' &&\n        onChangeListenTo?.includes(this.name as string)\n      ) {\n        linkedFields.push(field.instance)\n      }\n      if (cause === 'blur' && onBlurListenTo?.includes(this.name as string)) {\n        linkedFields.push(field.instance)\n      }\n    }\n\n    return linkedFields\n  }\n\n  /**\n   * @private\n   */\n  validateSync = (cause: ValidationCause) => {\n    const validates = getSyncValidatorArray(cause, this.options)\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getSyncValidatorArray(cause, field.options)\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<SyncValidator<any> & { field: FieldApi<any, any, any, any> }>,\n    )\n\n    // Needs type cast as eslint errantly believes this is always falsy\n    let hasErrored = false as boolean\n\n    this.form.store.batch(() => {\n      const validateFieldFn = (\n        field: FieldApi<any, any, any, any>,\n        validateObj: SyncValidator<any>,\n      ) => {\n        const error = normalizeError(\n          field.runValidator({\n            validate: validateObj.validate,\n            value: { value: field.getValue(), fieldApi: field },\n            type: 'validate',\n          }),\n        )\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n        if (field.state.meta.errorMap[errorMapKey] !== error) {\n          field.setMeta((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [getErrorMapKey(validateObj.cause)]: error,\n            },\n          }))\n        }\n        if (error) {\n          hasErrored = true\n        }\n      }\n\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n        validateFieldFn(this, validateObj)\n      }\n      for (const fieldValitateObj of linkedFieldValidates) {\n        if (!fieldValitateObj.validate) continue\n        validateFieldFn(fieldValitateObj.field, fieldValitateObj)\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n    if (\n      this.state.meta.errorMap[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.setMeta((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (cause: ValidationCause) => {\n    const validates = getAsyncValidatorArray(cause, this.options)\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getAsyncValidatorArray(cause, field.options)\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        AsyncValidator<any> & { field: FieldApi<any, any, any, any> }\n      >,\n    )\n\n    if (!this.state.meta.isValidating) {\n      this.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const validatesPromises: Promise<ValidationError | undefined>[] = []\n    const linkedPromises: Promise<ValidationError | undefined>[] = []\n\n    const validateFieldAsyncFn = (\n      field: FieldApi<any, any, any, any>,\n      validateObj: AsyncValidator<any>,\n      promises: Promise<ValidationError | undefined>[],\n    ) => {\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = field.getInfo().validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.getInfo().validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate,\n                      value: {\n                        value: field.getValue(),\n                        fieldApi: field,\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          if (controller.signal.aborted) return resolve(undefined)\n          const error = normalizeError(rawError)\n          field.setMeta((prev) => {\n            return {\n              ...prev,\n              errorMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorMap,\n                [getErrorMapKey(cause)]: error,\n              },\n            }\n          })\n\n          resolve(error)\n        }),\n      )\n    }\n\n    // TODO: Dedupe this logic to reduce bundle size\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      validateFieldAsyncFn(this, validateObj, validatesPromises)\n    }\n    for (const fieldValitateObj of linkedFieldValidates) {\n      if (!fieldValitateObj.validate) continue\n      validateFieldAsyncFn(\n        fieldValitateObj.field,\n        fieldValitateObj,\n        linkedPromises,\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (validatesPromises.length || linkedPromises.length) {\n      results = await Promise.all(validatesPromises)\n      await Promise.all(linkedPromises)\n    }\n\n    this.setMeta((prev) => ({ ...prev, isValidating: false }))\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: false }))\n    }\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * Validates the field value.\n   */\n  validate = (\n    cause: ValidationCause,\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // If the field is pristine and validatePristine is false, do not validate\n    if (!this.state.meta.isTouched) return []\n\n    try {\n      this.form.validate(cause)\n    } catch (_) {}\n\n    // Attempt to sync validate first\n    const { hasErrored } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      this.getInfo().validationMetaMap[\n        getErrorMapKey(cause)\n      ]?.lastAbortController.abort()\n      return this.state.meta.errors\n    }\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  /**\n   * Handles the change event.\n   */\n  handleChange = (updater: Updater<TData>) => {\n    this.setValue(updater)\n  }\n\n  /**\n   * Handles the blur event.\n   */\n  handleBlur = () => {\n    const prevTouched = this.state.meta.isTouched\n    if (!prevTouched) {\n      this.setMeta((prev) => ({ ...prev, isTouched: true }))\n      this.validate('change')\n    }\n    this.validate('blur')\n  }\n\n  /**\n   * Updates the field's errorMap\n   */\n  setErrorMap(errorMap: ValidationErrorMap) {\n    this.setMeta((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    if (typeof rawError !== 'string') {\n      return 'Invalid Form Values'\n    }\n\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n", "import type { FormApi } from './FormApi'\nimport type { Validator } from './types'\nimport type { NoInfer } from './util-types'\n\n/**\n * @private\n */\nexport function mutateMergeDeep(target: object, source: object): object {\n  const targetKeys = Object.keys(target)\n  const sourceKeys = Object.keys(source)\n  const keySet = new Set([...targetKeys, ...sourceKeys])\n  for (const key of keySet) {\n    const targetKey = key as never as keyof typeof target\n    const sourceKey = key as never as keyof typeof source\n    if (Array.isArray(target[targetKey]) && Array.isArray(source[sourceKey])) {\n      target[targetKey] = [\n        ...(target[targetKey] as []),\n        ...(source[sourceKey] as []),\n      ] as never\n    } else if (\n      typeof target[targetKey] === 'object' &&\n      typeof source[sourceKey] === 'object'\n    ) {\n      mutateMergeDeep(target[targetKey] as {}, source[sourceKey] as {})\n    } else {\n      // Prevent assigning undefined to target, only if undefined is not explicitly set on source\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!(sourceKey in source) && source[sourceKey] === undefined) {\n        continue\n      }\n      target[targetKey] = source[sourceKey] as never\n    }\n  }\n  return target\n}\n\nexport function mergeForm<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n>(\n  baseForm: FormApi<NoInfer<TFormData>, NoInfer<TFormValidator>>,\n  state: Partial<FormApi<TFormData, TFormValidator>['state']>,\n) {\n  mutateMergeDeep(baseForm.state, state)\n  return baseForm\n}\n", "import type { Validator } from './types'\nimport type { FormOptions } from './FormApi'\n\nexport function formOptions<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n>(defaultOpts?: FormOptions<TFormData, TFormValidator>) {\n  return defaultOpts\n}\n", "import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\nimport type { AnyUpdater, Store } from '@tanstack/store'\n\nexport * from '@tanstack/store'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport function useStore<\n  TState,\n  TSelected = NoInfer<TState>,\n  TUpdater extends AnyUpdater = AnyUpdater,\n>(\n  store: Store<TState, TUpdater>,\n  selector: (state: NoInfer<TState>) => TSelected = (d) => d as any,\n) {\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    shallow,\n  )\n\n  return slice\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false\n    for (const [k, v] of objA) {\n      if (!objB.has(k) || !Object.is(v, objB.get(k))) return false\n    }\n    return true\n  }\n\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false\n    for (const v of objA) {\n      if (!objB.has(v)) return false\n    }\n    return true\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n", "import { useEffect, useLayoutEffect } from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect\n", "import React, { type FunctionComponent, useState } from 'react'\nimport { useStore } from '@tanstack/react-store'\nimport { FieldApi, functionalUpdate } from '@tanstack/form-core'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\nimport type { NodeType, UseFieldOptions } from './types'\nimport type { DeepKeys, DeepValue, Validator } from '@tanstack/form-core'\n\ninterface ReactFieldApi<\n  TParentData,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n> {\n  /**\n   * A pre-bound and type-safe sub-field component using this field as a root.\n   */\n  Field: FieldComponent<TParentData, TFormValidator>\n}\n\n/**\n * A type representing a hook for using a field in a form with the given form data type.\n *\n * A function that takes an optional object with a `name` property and field options, and returns a `FieldApi` instance for the specified field.\n */\nexport type UseField<\n  TParentData,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n> = <\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n>(\n  opts: Omit<\n    UseFieldOptions<TParentData, TName, TFieldValidator, TFormValidator, TData>,\n    'form'\n  >,\n) => FieldApi<TParentData, TName, TFieldValidator, TFormValidator, TData>\n\n/**\n * A hook for managing a field in a form.\n * @param opts An object with field options.\n *\n * @returns The `FieldApi` instance for the specified field.\n */\nexport function useField<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n>(\n  opts: UseFieldOptions<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >,\n) {\n  const [fieldApi] = useState(() => {\n    const api = new FieldApi({\n      ...opts,\n      form: opts.form,\n      name: opts.name,\n    })\n\n    const extendedApi: typeof api & ReactFieldApi<TParentData, TFormValidator> =\n      api as never\n\n    extendedApi.Field = Field as never\n\n    return extendedApi\n  })\n\n  useIsomorphicLayoutEffect(fieldApi.mount, [fieldApi])\n\n  /**\n   * fieldApi.update should not have any side effects. Think of it like a `useRef`\n   * that we need to keep updated every render with the most up-to-date information.\n   */\n  useIsomorphicLayoutEffect(() => {\n    fieldApi.update(opts)\n  })\n\n  useStore(\n    fieldApi.store,\n    opts.mode === 'array'\n      ? (state) => {\n          return [state.meta, Object.keys(state.value ?? []).length]\n        }\n      : undefined,\n  )\n\n  return fieldApi\n}\n\n/**\n * @param children A render function that takes a field API instance and returns a React element.\n */\ntype FieldComponentProps<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = {\n  children: (\n    fieldApi: FieldApi<\n      TParentData,\n      TName,\n      TFieldValidator,\n      TFormValidator,\n      TData\n    >,\n  ) => NodeType\n} & UseFieldOptions<TParentData, TName, TFieldValidator, TFormValidator, TData>\n\n/**\n * A type alias representing a field component for a specific form data type.\n */\nexport type FieldComponent<\n  TParentData,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n> = <\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n>({\n  children,\n  ...fieldOptions\n}: Omit<\n  FieldComponentProps<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >,\n  'form'\n>) => NodeType\n\n/**\n * A function component that takes field options and a render function as children and returns a React component.\n *\n * The `Field` component uses the `useField` hook internally to manage the field instance.\n */\nexport const Field = (<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n>({\n  children,\n  ...fieldOptions\n}: FieldComponentProps<\n  TParentData,\n  TName,\n  TFieldValidator,\n  TFormValidator,\n  TData\n>): NodeType => {\n  const fieldApi = useField(fieldOptions as any)\n\n  return (<>{functionalUpdate(children, fieldApi as any)}</>) as never\n}) satisfies FunctionComponent<FieldComponentProps<any, any, any, any, any>>\n", "import { FormApi, functionalUpdate } from '@tanstack/form-core'\nimport { useStore } from '@tanstack/react-store'\nimport React, { useState } from 'react'\nimport { Field, type FieldComponent, type UseField, useField } from './useField'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\nimport type { NoInfer } from '@tanstack/react-store'\nimport type { FormOptions, FormState, Validator } from '@tanstack/form-core'\nimport type { NodeType } from './types'\n\n/**\n * Fields that are added onto the `FormAPI` from `@tanstack/form-core` and returned from `useForm`\n */\nexport interface ReactFormApi<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  /**\n   * A React component to render form fields. With this, you can render and manage individual form fields.\n   */\n  Field: FieldComponent<TFormData, TFormValidator>\n  /**\n   * A custom React hook that provides functionalities related to individual form fields. It gives you access to field values, errors, and allows you to set or update field values.\n   */\n  useField: UseField<TFormData, TFormValidator>\n  /**\n   * A `useStore` hook that connects to the internal store of the form. It can be used to access the form's current state or any other related state information. You can optionally pass in a selector function to cherry-pick specific parts of the state\n   */\n  useStore: <TSelected = NoInfer<FormState<TFormData>>>(\n    selector?: (state: NoInfer<FormState<TFormData>>) => TSelected,\n  ) => TSelected\n  /**\n   * A `Subscribe` function that allows you to listen and react to changes in the form's state. It's especially useful when you need to execute side effects or render specific components in response to state updates.\n   */\n  Subscribe: <TSelected = NoInfer<FormState<TFormData>>>(props: {\n    /**\n      TypeScript versions <=5.0.4 have a bug that prevents\n      the type of the `TSelected` generic from being inferred\n      from the return type of this method.\n\n      In these versions, `TSelected` will fall back to the default\n      type (or `unknown` if that's not defined).\n\n      @see {@link https://github.com/TanStack/form/pull/606/files#r1506715714 | This discussion on GitHub for the details}\n      @see {@link https://github.com/microsoft/TypeScript/issues/52786 | The bug report in `microsoft/TypeScript`}\n      */\n    selector?: (state: NoInfer<FormState<TFormData>>) => TSelected\n    children: ((state: NoInfer<TSelected>) => NodeType) | NodeType\n  }) => NodeType\n}\n\n/**\n * A custom React Hook that returns an extended instance of the `FormApi` class.\n *\n * This API encapsulates all the necessary functionalities related to the form. It allows you to manage form state, handle submissions, and interact with form fields\n */\nexport function useForm<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n>(opts?: FormOptions<TFormData, TFormValidator>) {\n  const [formApi] = useState(() => {\n    const api = new FormApi<TFormData, TFormValidator>(opts)\n\n    const extendedApi: typeof api & ReactFormApi<TFormData, TFormValidator> =\n      api as never\n    extendedApi.Field = function APIField(props) {\n      return (<Field {...props} form={api} />) as never\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    extendedApi.useField = (props) => useField({ ...props, form: api })\n    extendedApi.useStore = (selector) => {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      return useStore(api.store as any, selector as any) as any\n    }\n    extendedApi.Subscribe = (props) => {\n      return functionalUpdate(\n        props.children,\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useStore(api.store as any, props.selector as any),\n      ) as any\n    }\n\n    return extendedApi\n  })\n\n  useIsomorphicLayoutEffect(formApi.mount, [])\n\n  formApi.useStore((state) => state.isSubmitting)\n\n  /**\n   * formApi.update should not have any side effects. Think of it like a `useRef`\n   * that we need to keep updated every render with the most up-to-date information.\n   */\n  useIsomorphicLayoutEffect(() => {\n    formApi.update(opts)\n  })\n\n  return formApi\n}\n", "import type { FormApi, FormTransform, Validator } from '@tanstack/form-core'\n\nexport function useTransform<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n>(\n  fn: (formBase: FormApi<any, any>) => FormApi<TFormData, TFormValidator>,\n  deps: unknown[],\n): FormTransform<TFormData, TFormValidator> {\n  return {\n    fn,\n    deps,\n  }\n}\n"],
  "mappings": "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",
  "names": ["useState", "useLayoutEffect", "useEffect", "useEffect", "_a", "opts", "opts", "normalizeError", "getErrorMapKey"]
}
